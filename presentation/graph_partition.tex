%        File: graph_partition.tex
%     Created: Sun Mar 05 08:00 PM 2017 C
% Last Change: Sun Mar 05 08:00 PM 2017 C
%

\documentclass{beamer}
\usetheme{Boadilla}

\title{Multilevel $k$-way Partitioning Scheme for Irregular Graphs}
\subtitle{G. Karypis and V. Kumar}
\date{3/7/17}
\author{Trevor Steil}

\mode<presentation>{}

%\usepackage{amsmath}
%\usepackage{amsthm}
%\usepackage{amssymb}
%\usepackage{esint}
%\usepackage{enumitem}
%\usepackage{algorithm}
%\usepackage{algorithmicx}
%\usepackage{algpseudocode}
%\usepackage{bbm}
%\usepackage{xcolor}

%\newtheorem{theorem}{Theorem}[section]
%\newtheorem{corollary}{Corollary}[section]
%\newtheorem{proposition}{Proposition}[section]
%\newtheorem{lemma}{Lemma}[section]
%\newtheorem*{claim}{Claim}
%%\newtheorem*{problem}{Problem}
%%\newtheorem*{lemma}{Lemma}
%\newtheorem{definition}{Definition}[section]
%
%\newcommand{\R}{\mathbb{R}}
%\newcommand{\N}{\mathbb{N}}
%\newcommand{\C}{\mathbb{C}}
%\newcommand{\Z}{\mathbb{Z}}
%\newcommand{\Q}{\mathbb{Q}}
%\newcommand{\E}{\mathbb{E}}
%\newcommand{\supp}[1]{\mathop{\mathrm{supp}}\left(#1\right)}
%\newcommand{\lip}[1]{\mathop{\mathrm{Lip}}\left(#1\right)}
%\newcommand{\curl}{\mathrm{curl}}
%\newcommand{\la}{\left \langle}
%\newcommand{\ra}{\right \rangle}
%\renewcommand{\vec}[1]{\mathbf{#1}}
%\renewcommand{\div}{\mathrm{div}}
%
%\newenvironment{problem}{\textbf{Problem.}}
%
%\newenvironment{solution}[1][]{\emph{Solution #1}}
%
%\algnewcommand{\Or}{\textbf{ or }}
%\algnewcommand{\And}{\textbf{ or }}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Table of Contents}
  \tableofcontents
\end{frame}

\section{Introduction}
\begin{frame}
  \frametitle{Graph Partitioning}

  Given a graph $G = (V, E)$ with $|V|=n$, we want to partition $V$ into subsets $V_1, \dots, V_k$ such that
  \begin{itemize}
    \item $V_i \cap V_j = \emptyset$ for $i \neq j$
    \item $\cup_{i=1}^k V_i = V$
    \item $|V_i| = \frac{n}{k}$ for all $i$ (approximately at least)
    \item number of edges with vertices in different subsets is minimized
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Uses of Graph Partitioning}

  \begin{itemize}
    \item Assigning tasks to processors in parallel computation to minimize communication costs
    \item Sparse matrix-vector multiplication
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Recursive Bisection}

  Can repeatedly partition graph in two
  \begin{itemize}
    \item Recursive Bisection
    \item Recursive nature leads to logarithmic term in running time ($O(|E| \log k)$)
  \end{itemize}

  Partitioning graph in two is still difficult to do.

\end{frame}

\begin{frame}
  \frametitle{Multilevel k-Way Partitioning}

  \begin{block}{Idea:}
    It is easier to partition smaller graphs
  \end{block}

  Instead of trying to partition original graph, try reducing to a smaller graph.

\end{frame}

\section{Algorithm}

\begin{frame}
  \frametitle{Basic Algorithm Steps}

  \begin{enumerate}
    \item
      Successively coarsen graph
    \item
      Partition coarsest graph
    \item
      Uncoarsen graph and refine partition
  \end{enumerate}

  INSERT PICTURE FROM PAPER!!!!!!!!!!!!!!!!!!!

\end{frame}

\subsection{Coarsening Phase}

\begin{frame}
  \frametitle{Coarsening Phase}

  Let $G_0 = (V_0, E_0) = (V,E)$ be the original graph. Want a sequence $G_i = (V_i, E_i)$ with $|V_i| < |V_{i-1}|$.

  Need to add weights to vertices and edges to keep track of number of original vertices and edges are in each coarsened vertex and edge.

\end{frame}

\begin{frame}
  \frametitle{Use of Matchings}

  Can rephrase coarsening as finding a matching and collapsing along edges of matching.

  Matchings are often done using randomized algorithm.
  \begin{itemize}
    \item Vertices visited in random order
    \item At each vertex, a random unmatched neighbor is chosen (if any exist)
    \item Corresponding edge is added to matching
  \end{itemize}

  GIVE EXAMPLE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

\end{frame}

\begin{frame}
  \frametitle{Heavy Edge Matching}

  Each coarsening step, reduces the total weight of edges by the weights of edges in the matching.
  \begin{itemize}
    \item To minimize edge cut, choose edges that maximize weight of matching
  \end{itemize}

  Algorithm:
  \begin{itemize}
    \item Visit vertices in random order
    \item At each vertex, choose unmatched neighbor along heaviest edge
    \item Add corresponding edge to matching
  \end{itemize}

  Has same computational complexity as randomized matching ($O(|E|)$)
\end{frame}

\subsection{Initial Partitioning}

\begin{frame}
  \frametitle{Initial Partitioning}

  Partition $G_n=(V_n,E_n)$ into $k$ subsets after several iterations using any method
  \begin{itemize}
    \item Can use recursive bisection, spectal bisection, etc.
  \end{itemize}

  Want to enforce
  \begin{itemize}
    \item Vertex weights are approximately equal among partitions
  \end{itemize}

\end{frame}

\subsection{Uncoarsening Phase}

\begin{frame}
  \frametitle{Uncoarsening Phase}

  Basic Steps:
  \begin{itemize}
    \item Take partitioning of $G_i$ to a partitioning of $G_{i-1}$ by reversing the matching and collapse of coarsening that sent $G_{i-1}$ to $G_i$.
    \item Refine partition to have lower edge cut
  \end{itemize}

  Many refining algorithms exist, based on various heuristics.

\end{frame}

\begin{frame}
  \frametitle{Kernighan-Lin (KL) Algorithm}

  Used for bisection (not $k$-way partitioning)

  For a vertex $v$, let $gain(v)$ be the decrease in edge-cut when $v$ is moved to the other subset of the partition.

  \begin{itemize}
    \item Compute $gain$ of all vertices
    \item Create priority queue for each subset of partition based on $gain$
    \item Choose $v$ with highest $gain$
      \begin{itemize}
        \item Move $v$ to other subset
        \item Update gain of neighbors of $v$
        \item Store current edge-cut
        \item Lock $v$ so it cannot be moved
      \end{itemize}
  \end{itemize}

  Afterward, choose configuration that had lowest edge-cut

\end{frame}

\end{document}


